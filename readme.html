**Gradebook DSL**


Author
===============

<div class="noheader firstcol">
    |             
------------------|-------------
name              | Daniel Gibson & Trevor Mitchell
computer + OS     | Euler lab machines (Linux)
</div>


Introduction to Language
===============

Domain
-------
Teachers managing a CSV gradebook

Problem
---------------
This language is meant to enable educators to perform
manipulations on a gradebook, such as getting the highest / lowest 
grade, an average for an assignment, or even curving a grade or 
applying a new weighting system.


Variable Types and Declarations
================================

file:
--------
a CSV file that has been read in as a 2d array

Example:

`read foo.csv as bar;` creates a file variable named bar.

`read foo.csv as bar (noColHeaders)` You can also add flags if your spreadsheet does not contain headers, such as the
sample below which contains no column headers. Options include `(noColHeaders, noRowHeaders)`

<div class="noheader">
                  |    |    |    | 
------------------|----|----|----|----
Quiz1Scores       | 12 | 14 | 10 | 12
Quiz2Scores       | 43 | 44 | 39 | 45
</div>


headers:
--------
upon reading in a file, the script is populated with variables that refer to row and column headers, allowing
the programmer to access cells with `tableVar.colHeaderName.rowHeaderName`. If the noRowHeader or noColHeader is set,
the respective field is populated with headers "row_1, row_2, ..."

If a header cell is empty, its name will become "col_n" where n is the index of the header. If a row and column have
the same name, the "_row" is appended to the end of the row. If two columns share the same name, then the second one
will have "_n" appended at the end, where n is the occurrence (2 for the second, 3 for the third, and so on)

subset:
-------
an object that contains a set of specified cells that can all be manipulated at once.

Examples:

`subset foo = [table.row.col to table.row2.col2];` creates a subset that contains all cells bounded by the
two cells.

`subset foo = [row a to row b];` contains all cells in the box bounded by those rows. The language can use `col`
but cannot compute a range of a row to a column.

`subset foo = [table.col.row, col a to col b];` Using commas, the programmer can specify a set of cells that are
not connected.

cell:
---------
a reference to a specific cell in a specific table.

Example:

`cell foo = table.col.row;` creates a cell variable 'foo' that refers to the reference.

function
----------
Defines a mathematical function to apply to a subset in the output section.

The `value` keyword is used to access the current value in the cell being manipulated.

You can also access the current cell's location by using `this.col` or `this.foo.row`, allowing
you to access a different cell in the same row or the same column.

Examples:

`function add2 = value + 2;` adds 2 to each cell in the subset.

`function convertToPercent = value / this.col.total;` accesses the cells value and divides it by the total value
for that same column (works if assignments are separated by column).

Script Overview
===============

Overview
----------------

A file is made up of three primary sections, defined as follows:

~~~
input:

end input;

actions:

end actions;

output:

end output;
~~~

Key functionality is split between these three sections.
Below is a description of each of these phases.

Input
----------------

Given a csv file, the language will create variables for the 2d array of data, the column headers, and the row headers.

**Invalid characters**: If a column header contains invalid characters, such as '&'' or '$', they will be removed from the column reference.
Spaces in column headers will be replaced with underscores.

**Conflicting names**: If 2 columns contain the same name, the second one will have the number 1 appended to the end, and the next 2, and so on.
If a column and row share the same name, '_row' will be appended to the row version.

To read in a file, utilize the following line:

~~~
read filename.csv as fileVariable;
~~~

where `filename` is the path to the file being read in,
and `fileVariable` is the name for the variable used to 
represent the spreadsheet.

Because variable names are used load in a spreadsheet,
multiple files can be read into one script.

Actions
---------------

Actions consist of the bulk of the script. New subsets can be defined, 
special functions can be declared designed to manipulate data,
and operations such as minimum, maximum and average can be applied to 
a set of data. These are all applied in the 
`output` section of the program.

The actions section is intended to define any 
modifications to be made to the data. This way, all 
computation is contained within the actions section, 
and the output section only uses the precomputed 
data types to prepare the output.

**Subsets** are intended to represent a specific set of 
data within a spreadsheet. They can be declared in the following 
format:

~~~
fileVariable subset subsetVariable = [ref];
~~~

`fileVariable` is the spreadsheet being referenced, and `subsetVariable` 
is the variable name this subset is assigned to.
`ref` is a generic term used here as a placeholder for the 
multiple types of input that can be used for a subset, which 
include the following:

~~~
file subset sub1 = [col quiz1];
file subset sub2 = [row tommy];
file subset sub3 = [tommy.quiz1];
file subset sub4 = [col quiz1, col quiz2];
file subset sub5 = [col quiz1 to col quiz3];
file subset sub6 = [col quiz1, row tommy to row billy];
file subset sub7 = [col quiz1, col quiz3, tommy.quiz4 to billy.quiz6];
~~~

There is lots of potential to control the input of a subset.
Subsets can be declared from a row, column, cell reference, or a range 
and/or combiation of any of the above. This allows for a powerful 
tool to disect a dataset. 

Important to note: subset names must be distinct 
from row/column headers!

**Cell variables** are used to refer to a specific cell.
They can be defined in the following formats:

~~~
cell cell1 = this.col.quiz4;
cell cell2 = this.tommy.row;
cell cell3 = file.tommy.quiz4;
cell cell4 = cell3;
~~~

In the first two cases, the cell being referenced is more general,
referring to cells that meet a specific criteria. This is designed 
for use in functions, where the `row` or `col` may change depending 
on the cell being accessed. More on this below.

In the third case, there is one cell being referenced, providing 
the file variable, the row name, and the column name. In the 
fourth case, a previously defined cell variable is accessed.

**Functions** are pre-defined operations used to cause a modification 
to a certain set of data. Functions are declared in the following format:

~~~
function funcVar = expr;
~~~

`funcVar` is the variable name of the function, and `expr` is a 
placeholder used to represent the different operations that 
can be used in a function. These operations include addition, 
subtraction, multiplication, division, and any combination of 
the above. Complicated operations also support use of parentheses 
to express calculation order and utilize standard order of operations.

As discussed earlier, functions also allow for the use of cell 
variables to define expressions. Consider the following lines:

~~~
cell totalCell = this.row.total;
function getPercent = value / totalCell;
~~~

When the `getPercent` function is applied to a subset in 
the program will iterate through each element in the subset.
As it iterates and accesses each cell, it will update the `row` 
attribute in the `totalCell` definition to be the `row` used in 
the current iterator cell. This allows for functions that 
work across a wider range of cells.

Because functions are not applied until the `output` phase, they can 
be defined generally and can be used on multiple stored files.

**Num Variables** are used to store numerical values. They are 
defined in the following format:

~~~
num num1 = 1;
num num2 = 2.5;
num num3 = (5 + 17) / 3;
~~~

Numerical variables can also be used to calculate the min, max or 
average of a subset. This is defined as follows:

~~~
num minVal = min set1;
num maxVal = max set2;
num avgVal = avg set3 max 100;
~~~

The `avg` operator requires a maximum value to be 
specified to calculate the average, allowing an instructor 
to test multiple possibilities for class scores.

It is important to note that these actions are simply stored 
until the `output` phase; currently they are not used in any way.

Output
---------------

The output section is used to define the structure of the resulting file. 
It applies functions to certain subsets 
and writes those results to the specified CSV file,
as well as allowing a user to append additional variables 
to that file.

There are three key operations in the `output` phase:
functions, additions, and writes.

**Function Application** is when a previously defined 
function is applied to a subset. This looks like the 
following:

~~~
use funcVar on subsetVar;
~~~

The operation specified in the `funcVar` function is applied to every 
cell in the `subsetVar` subset.

**Addition of Variables** allows the user to output numerical 
variables at the end of the output file. This is specified 
in the following format:

~~~
add numVar to fileVar;
~~~

`numVar` is the numerical variable previously defined, while 
`fileVar` is the file variable the user wishes to append the 
variable onto. The extra variables are added onto the bottom 
of the output CSV file, including a header with the text 
"Extra Variables" above them. Both the variable names and 
values are outputted to allow the user to track which 
data they are outputting.

**TODO** - add info about ordering here

The **write** section allows the user to finally take all 
their prepared actions and output them to a CSV file. This 
is defined in the following format:

~~~
write fileVar to filename.csv;
~~~

`fileVar` is the file variable the user wishes to output, 
and `filename.csv` is the file the user wishes to write out to.


Sample Program
===============

Consider the following CSV file:

![Example gradebook CSV file](./screenshots/gradebook1-csv.jpg)

The following code is an example of a program written 
in this language. This is what we used to test the 
grammar and help structure it.

~~~
input:

read testEnv/gradebook.csv as gradesTable;

end input;


actions:

gradesTable subset quiz1set = [col quiz1];

function add2ExtraCredit = value + 2;

num val1 = 4;
num m_score = max quiz1set;
num min_score = min quiz1set;
num a_score = avg quiz1set max 100;
num expr_val = 5 + (9 * 3);

end actions;


output:

use add2ExtraCredit on quiz1set;
add m_score to gradesTable;
add a_score to gradesTable;
add min_score to gradesTable;
add val1 to gradesTable;
write gradesTable out.csv;

end output;
~~~

Once this script has run, this is the resulting output CSV file:

(screenshot here)

Grammar
===============

The following grammar is defined for the program:

~~~
INSERT FINAL GRAMMAR HERE
~~~

The grammar matches the program as expected and is 
able to handle all the functionality we have currently 
designed the program with.


Translation Behind-The-Scenes
=======================

Variables
--------
All input files are read in as 2d arrays of strings. Those strings are then stored in a HashMap data type with the
key being the variable name the user assigned to that input file.

**Headers:** There are 2 separate HashMaps. One for column headers and the other for row headers. The key is the
header name and the value is the index of that row/column in the corresponding file's 2d array

**Subsets:** Subsets are a class that contain the string of the in-file name and a linked list of cell locations. Subset
variables are stored in a HashTable.

**Cells:** Cells can be referenced by the format fileVar.colHeader.rowHeader or by variable name if previously declared
using `cell foo = inFile.col.row`. It can be used to access the value at that cell or to define a range or location in
a subset. Visiting a cellReference returns the location of the cell and sets the currentCell value to the proper cell
object, which contains the in-file variable name and the cell location within that file, as well as a getVal function.

Output
------
In the output, functions can be applied to certain subsets. This is achieved by store the function context at assignment
and visiting it while parsing the use rule.
rammar. We may also go back and restructure
the grammar in places to make it less ambiguous, especially
if we discover issues further down the line. However,
at this point in time the grammar works quite well for
our purposes and provides a strong starting point for
developing the language.

P02
---------------

At this point, the grammar should be fully functional. Perhaps some adjustments will be made to simplify parser
implementation. The grammar has displayed expected behavior for various syntax errors and valid inputs.

P03
--------------

We made some adjustments to the grammar based on what we thought would 
be useful for the user.
We decided that for loops were unnecessarily complicated - both 
for the user and for the implementation - so we replaced them with 
a number variable assignment that can also implement an 
minimum, maximum, and average operation of a subset. 
We did this because the number of contexts where for loops 
would be used was quite slim, so we removed them while also 
maintaining and simplifying their most common use case.
We also decided to remove schemes, as we didn't have time to fully 
define what their use would be and to get a good understanding of 
how they would be implemented. They only provided a minor part 
of functionality, so that wasn't too concerning.

However, we saw some promising results with subsets and functions! 
The subset/rule functionality should give some powerful options for 
the user to analyze and manipulate data. In addition, the min/max/avg 
operators were a nice addition to the language.

We still need to put some finishing touches on the output phase 
of the program, but overall we're pretty encouraged by the progress 
we've seen!



<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
