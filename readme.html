**Gradebook DSL**


Author
===============

<div class="noheader firstcol">
    |             
------------------|-------------
name              | Daniel Gibson & Trevor Mitchell
computer + OS     | Euler lab machines (Linux)
</div>

Introduction to Language
===============

**Domain:** Teachers managing a CSV gradebook

**Problem:** This language is meant to enable educators to perform 
manipulations on a gradebook, such as getting the highest / lowest 
grade, an average for an assignment, or even curving a grade or 
applying a new weighting system.


Variable Types and Declarations
================================

`file`: a CSV file that has been read in as a 2d array

`subset`: an object that contains a list of cell locations and the file it refers to.

`cell`: an object that contains the file it resides in, the row index, and the col index.

Script Overview
===============

Input
----------------

Given a csv file, the language will convert it to a subset variable with the column headers and rows as their respective objects.

**Invalid characters**: If a column header contains invalid characters, such as '&'' or '$', they will be removed from the column reference.
Spaces in column headers will be replaced with underscores.

**Conflicting names**: If 2 columns contain the same name, the second one will have the number 1 appended to the end, and the next 2, and so on.
If a column and row share the same name, '_col' will be appended to the column version, and '_row' to the row version.

Actions
---------------

Actions consist of the bulk of the script. New subsets can be defined, 
conditional statements and loops can provide manipulations to data, and
weight systems aka schemes, can be declared. These are all applied in the 
`output` section of the program.

The actions section is intended to define any 
modifications to be made to the data. This way, all 
computation is contained within the actions section, 
and the output section only uses the precomputed 
data types to prepare the output.

**For loops ** will likely not be implemented super often, as functions can be applied to each cell in a set. However,
it still does provide some usefulness, especially when combined with conditional statements to only modify cells that
match a given criteria. The first ID in a for loop statement will be the variable name of the current cell, and the second
ID will be the set that is being iterated over.

Output
---------------

The output section is used to define the structure of the resulting file. 
It applies pre-defined schemes, rules and functions to certain subsets 
and writes those results to the specified CSV file.

Sample Program
===============

The following code is an example of a program written 
in this language. This is what we used to test the 
grammar and help structure it.

~~~
input:

read filepath.csv as inFile;    //populates an inFile variable with key-value pairs of columns, which is an object of key-value pairs of rows 
                                //that contain cell data.
read secondFile.csv as alterate (noRowHeader);

end input;


actions:

subset quiz = [quiz1, quiz2 to quiz5];  //Defined using row names
subset groupA = [tommy, billy, joe];    //Defined using col names
subset bestQuizGrades = [tommy.quiz4, billy.quiz2];  //Defined using individual cells

function add2ExtraCredit = value + 2; //Functions can be applied to sets of values to set the new value = to the old one + 2 in this instance.
function convertToPercent = value / total.value;    //This example can be used for a table that inputs quizes as a score and has a column for
                                                    //Each student as well as a "total" column for the highest possible.

scheme classWeights = {       //For each column in a given subset, averages the values of the subset as value then performs a function
    quiz: value * .2,     //Performs an action on the given subset
    test: value * .4,
    project: value *.4,
}

cell max = tommy.quiz2
for entry in quiz2: //Iterates through each cell object in a subset.
    if (entry > max): //Compares entry cell.value to max cell.value
        cell max = entry;
    end if;
end for;

end actions;


output:

use classWeights on inFile;
use add2ExtraCredit on groupA.quiz2;
write inFile out.csv;

end output;
~~~

Grammar
===============

The following grammar is defined for the program:

~~~
grammar CSVScript;

start   : input actions output EOF ;

input   : 'input:' inputStatement 'end input' ';' ;
inputStatement  : 'read' filename 'as' ID inputFlags ';' inputStatement
| /* epsilon */
;
inputFlags      : '(' inputFlag ')'
| /* epsilon */
;
inputFlag       : 'noRowHeader'
| 'noColHeader'
| 'noRowHeader' ',' 'noColHeader'
| 'noColHeader' ',' 'noRowHeader'
;
/*End input phase*/

actions			: 'actions:' actionBlock 'end actions' ';' ;
actionBlock		: action ';' actionBlock
| /* epsilon */
;
action			: ifStatement
| forStatement
| subsetAssignment
| cellAssignment
| schemeAssignment
| functionAssignment
;

subsetAssignment: 'subset' ID '=' set;
set				: '[' references ']';
references		: reference
| reference ',' references
| /* epsilon */
;
reference		: ID // row or column name
| ID '.' ID // colName.rowName
| reference 'to' reference
;

cellAssignment	: 'cell' ID '=' reference;

schemeAssignment: 'scheme' ID '=' '{' r '}';

r				: ID ':' expr rules;

rules			: ',' r rules //ID corresponds to a subset or cell
|
;
expr			: term terms ;
/*The below code was ripped from A02 to register mathematical expressions*/
terms			: '+' term terms
| '-' term terms
| ;

term			: factor factors;

factors			: '*' factor factors
| '/' factor factors
| 'mod' factor factors
| ;

factor			: '(' expr ')'
| value
| ID '.' ID //This ID should be a reference to a column or row
;
/*End Math portion*/

functionAssignment: 'function' ID '=' expr ; //A rule is a mathematical operation to apply to the value of a cell or subset

ifStatement		: 'if' '(' conditional ')' actionBlock 'end if';

forStatement	: 'for' ID 'in' ID actionBlock 'end for'
| 'for' ID 'in' set actionBlock 'end for'
;

conditional		: value OPERATOR value
| '('conditional')' 'and' '('conditional')'
| '('conditional')' 'or' '('conditional')'
;

value			: INT
| ID
| realNumber
;
/*End actions phase*/

output          : 'output:' outputStatement 'end output' ';' ;
outputStatement : outputRule outputWrite ;

outputRule      : 'use' ID 'on' reference ';' outputRule //first ID corresponds to rule. Second ID corresponds to set.
| /* epsilon */
;

outputWrite     : 'write' ID filename ';' ; //ID corresponds to a subsection

filename		: ID '.csv'
| ALPHANUM '.csv';

realNumber		: INT '.' INT ;

INT     : [0-9]+ ;
ID      : [a-zA-Z_] [0-9a-zA-Z_]+ ;
NEWLINE : '\r'? '\n' -> skip;
WS      : [ \t]+ -> skip ;  // tells ANTLR to ignore these
OPERATOR: ('>=' | '<=' | '>' | '<' | '==' | '!=');
ALPHANUM: [0-9a-zA-Z_]+ ;
~~~

The grammar matches the program as expected and is 
able to handle all the functionality we have currently 
designed the program with.

Testing
====================
A whole suite of test files were used to check against isolated issues, such as no output file, an integer being used
as a variable id, actions in the output block, and no input block. We also tested against a larger script that should
utilize most, if not all of the grammar rules.

Reflection
===================

P01
-------------
This grammar is not exhaustive, but it covers most cases
fairly well. It is possible that we will add more functionality
to the language in the future, in which case we would
have to add to the grammar. We may also go back and restructure
the grammar in places to make it less ambiguous, especially
if we discover issues further down the line. However,
at this point in time the grammar works quite well for
our purposes and provides a strong starting point for
developing the language.

P02
---------------
At this point, the grammar should be fully functional. Perhaps some adjustments will be made to simplify parser
implementation. The grammar has displayed expected behavior for various syntax errors and valid inputs.




<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
