**Gradebook DSL**


Author
===============

<div class="noheader firstcol">
    |             
------------------|-------------
name              | Daniel Gibson & Trevor Mitchell
computer + OS     | Euler lab machines (Linux)
</div>


Introduction to Language
===============

Domain
-------
Teachers managing a CSV gradebook

Problem
---------------
This language is meant to enable educators to perform
manipulations on a gradebook, such as getting the highest / lowest 
grade, an average for an assignment, or even curving a grade or 
applying a new weighting system.


Variable Types and Declarations
================================

file:
--------
a CSV file that has been read in as a 2d array

Example:

`read foo.csv as bar;` creates a file variable named bar.

`read foo.csv as bar (noColHeaders)` You can also add flags if your spreadsheet does not contain headers, such as the
sample below which contains no column headers. Options include `(noColHeaders, noRowHeaders)`

<div class="noheader">
                  |    |    |    | 
------------------|----|----|----|----
Quiz1Scores       | 12 | 14 | 10 | 12
Quiz2Scores       | 43 | 44 | 39 | 45
</div>


headers:
--------
upon reading in a file, the script is populated with variables that refer to row and column headers, allowing
the programmer to access cells with `tableVar.colHeaderName.rowHeaderName`. If the noRowHeader or noColHeader is set,
the respective field is populated with headers "row_1, row_2, ..."

If a header cell is empty, its name will become "col_n" where n is the index of the header. If a row and column have
the same name, the "_row" is appended to the end of the row. If two columns share the same name, then the second one
will have "_n" appended at the end, where n is the occurrence (2 for the second, 3 for the third, and so on)

subset:
-------
an object that contains a set of specified cells that can all be manipulated at once.

Examples:

`subset foo = [table.row.col to table.row2.col2];` creates a subset that contains all cells bounded by the
two cells.

`subset foo = [row a to row b];` contains all cells in the box bounded by those rows. The language can use `col`
but cannot compute a range of a row to a column.

`subset foo = [table.col.row, col a to col b];` Using commas, the programmer can specify a set of cells that are
not connected.

cell:
---------
a reference to a specific cell in a specific table.

Example:

`cell foo = table.col.row;` creates a cell variable 'foo' that refers to the reference.

function
----------
Defines a mathematical function to apply to a subset in the output section.

The `value` keyword is used to access the current value in the cell being manipulated.

You can also access the current cell's location by using `this.col` or `this.foo.row`, allowing
you to access a different cell in the same row or the same column.

Examples:

`function add2 = value + 2;` adds 2 to each cell in the subset.

`function convertToPercent = value / this.col.total;` accesses the cells value and divides it by the total value
for that same column (works if assignments are separated by column).

Script Overview
===============

Overview
----------------

A file is made up of three primary sections, defined as follows:

~~~
input:

end input;

actions:

end actions;

output:

end output;
~~~

Key functionality is split between these three sections.
Below is a description of each of these phases.

Input
----------------

Given a csv file, the language will create variables for the 2d array of data, the column headers, and the row headers.

**Invalid characters**: If a column header contains invalid characters, such as '&'' or '$', they will be removed from the column reference.
Spaces in column headers will be replaced with underscores.

**Conflicting names**: If 2 columns contain the same name, the second one will have the number 1 appended to the end, and the next 2, and so on.
If a column and row share the same name, '_row' will be appended to the row version.

Files are read in using the following format:

~~~
read filename.csv as fileVariable;
~~~

where `filename` is the path to the file being read in,
and `fileVariable` is the name for the variable used to 
represent the spreadsheet.

Because variable names are used load in a spreadsheet,
multiple files can be read into one script.

Actions
---------------

Actions consist of the bulk of the script. New subsets can be defined, 
special functions can be declared designed to manipulate data,
and operations such as minimum, maximum and average can be applied to 
a set of data. These are all applied in the 
`output` section of the program.

The actions section is intended to define any 
modifications to be made to the data. This way, all 
computation is contained within the actions section, 
and the output section only uses the precomputed 
data types to prepare the output.

**Subsets** are intended to represent a specific set of 
data within a spreadsheet. They can be declared in the following 
format:

~~~
fileVariable subset subsetVariable = [ref];
~~~

`fileVariable` is the spreadsheet being referenced, and `subsetVariable` 
is the variable name this subset is assigned to.
`ref` is a generic term used here as a placeholder for the 
multiple types of input that can be used for a subset, which 
include the following:

~~~
file subset sub1 = [col quiz1];
file subset sub2 = [row tommy];
file subset sub3 = [tommy.quiz1];
file subset sub4 = [col quiz1, col quiz2];
file subset sub5 = [col quiz1 to col quiz3];
file subset sub6 = [col quiz1, row tommy to row billy];
file subset sub7 = [col quiz1, col quiz3, tommy.quiz4 to billy.quiz6];
~~~

There is lots of potential to control the input of a subset.
Subsets can be declared from a row, column, cell reference, or a range 
and/or combiation of any of the above. This allows for a powerful 
tool to disect a dataset. 

Important to note: subset names must be distinct 
from row/column headers!

**Cell variables** are used to refer to a specific cell.
They can be defined in the following formats:

~~~
cell cell1 = this.col.quiz4;
cell cell2 = this.tommy.row;
cell cell3 = file.tommy.quiz4;
cell cell4 = cell3;
~~~

In the first two cases, the cell being referenced is more general,
referring to cells that meet a specific criteria. This is designed 
for use in functions, where the `row` or `col` may change depending 
on the cell being accessed. More on this below.

In the third case, there is one cell being referenced, providing 
the file variable, the row name, and the column name. In the 
fourth case, a previously defined cell variable is accessed.

**Functions** are pre-defined operations used to cause a modification 
to a certain set of data. Functions are declared in the following format:

~~~
function funcVar = expr;
~~~

`funcVar` is the variable name of the function, and `expr` is a 
placeholder used to represent the different operations that 
can be used in a function. These operations include addition, 
subtraction, multiplication, division, and any combination of 
the above. Complicated operations also support use of parentheses 
to express calculation order and utilize standard order of operations.

As discussed earlier, functions also allow for the use of cell 
variables to define expressions. Consider the following lines:

~~~
cell totalCell = this.row.total;
function getPercent = value / totalCell;
~~~

When the `getPercent` function is applied to a subset in 
the program will iterate through each element in the subset.
As it iterates and accesses each cell, it will update the `row` 
attribute in the `totalCell` definition to be the `row` used in 
the current iterator cell. This allows for functions that 
work across a wider range of cells.

Because functions are not applied until the `output` phase, they can 
be defined generally and can be used on multiple stored files.

**Num Variables** are used to store numerical values. They are 
defined in the following format:

~~~
num num1 = 1;
num num2 = 2.5;
num num3 = (5 + 17) / 3;
~~~

Numerical variables can also be used to calculate the min, max or 
average of a subset. This is defined as follows:

~~~
num minVal = min set1;
num maxVal = max set2;
num avgVal = avg set3 max 100;
~~~

The `avg` operator requires a maximum value to be 
specified to calculate the average, allowing an instructor 
to test multiple possibilities for class scores.

It is important to note that these actions are simply stored 
until the `output` phase; currently they are not used in any way.

Output
---------------

The output section is used to define the structure of the resulting file. 
It applies functions to certain subsets 
and writes those results to the specified CSV file,
as well as allowing a user to append additional variables 
to that file.

There are three key operations in the `output` phase:
functions, additions, and writes.

**Function Application** is when a previously defined 
function is applied to a subset. This looks like the 
following:

~~~
use funcVar on subsetVar;
~~~

The operation specified in the `funcVar` function is applied to every 
cell in the `subsetVar` subset.

**Addition of Variables** allows the user to output numerical 
variables at the end of the output file. This is specified 
in the following format:

~~~
add numVar to fileVar;
~~~

`numVar` is the numerical variable previously defined, while 
`fileVar` is the file variable the user wishes to append the 
variable onto. The extra variables are added onto the bottom 
of the output CSV file, including a header with the text 
"Extra Variables" above them. Both the variable names and 
values are outputted to allow the user to track which 
data they are outputting.

Something important to consider is the ordering of the usage 
of function application and variable addition. Consider the 
following code:

~~~
add quiz1_avg to gradeFile;
use add_extra_credit on quiz1set;
~~~

Assuming `quiz1_avg` is pulled from the `quiz1set` subset, 
this will take the average of quiz1 scores before the extra credit 
is applied. However, the following code:

~~~
use add_extra_credit on quiz1set;
add quiz1_avg to gradeFile;
~~~

will take the average of quiz1 scores after the extra credit 
is applied. This ordering allows for powerful uses, including 
the ability to view an average score before and after a 
function is applied. For example, the following code

~~~
add quiz_avg to gradeFile;
use add_extra_credit on quizzes;
add quiz_avg to gradeFile;
~~~

will give the average quiz score before and after the extra 
credit is applied. When one numerical variable is added to 
an output file multiple times, a number is used to track 
and differentiate the variables. For example, the above 
code will result in the following output:

![Quiz scores before and after extra credit](./screenshots/mult-num-vars.JPG)

The **write** section allows the user to finally take all 
their prepared actions and output them to a CSV file. This 
is defined in the following format:

~~~
write fileVar to filename.csv;
~~~

`fileVar` is the file variable the user wishes to output, 
and `filename.csv` is the file the user wishes to write out to.

Running a Program
----------

Running a program is quite simple. From the Intellij menu, 
simply run a configuration for the `startTranslator` class and 
pass the script text file as the program argument. Then 
click run!


Sample Program
===============

Consider the following CSV file:

![Example gradebook CSV file](./screenshots/gradebook1-csv.jpg)

The following code is an example of a program written 
in this language. This is what we used to test the 
grammar and help structure it.

~~~
input:

read testEnv/gradebook.csv as gradesTable;

end input;


actions:

gradesTable subset quiz1set = [col quiz1];

function add2ExtraCredit = value + 2;

num val1 = 4;
num m_score = max quiz1set;
num min_score = min quiz1set;
num a_score = avg quiz1set max 100;
num expr_val = 5 + (9 * 3);

end actions;


output:

use add2ExtraCredit on quiz1set;
add m_score to gradesTable;
add a_score to gradesTable;
add min_score to gradesTable;
add val1 to gradesTable;
write gradesTable out.csv;

end output;
~~~

Once this script has run, this is the resulting output CSV file:

![Resulting CSV file](./screenshots/gradebookout-csv.JPG)

Other Example Inputs and Outputs
===============

grades2-functions
--------------

Input CSV:

![grades2.csv](./screenshots/grades2.JPG)

Script:

~~~
input:
read testEnv/grades2.csv as gradeFile;
end input;

actions:
gradeFile subset hw = [col hw1 to col hw5];
gradeFile subset quizzes = [col quiz1 to col quiz5];
gradeFile subset tests = [col test1, col test2];
gradeFile subset finalSet = [col final];

function get_percent = (value / 100);
function add_extra_credit = value + 5;
num hw_avg = avg hw max 100;
num quiz_avg = avg quizzes max 100;
num test_avg = avg tests max 100;
num final_avg = avg finalSet max 100;

end actions;

output:
add quiz_avg to gradeFile;
use add_extra_credit on quizzes;
add quiz_avg to gradeFile;
write gradeFile ../outputs/quiz-scores.csv;
end output;
~~~

Output:

![quiz-scores.csv](./screenshots/quiz-scores.JPG)

grades2-avgs
-------------

Input:

![grades2.csv](./screenshots/grades2.JPG)

Script:

~~~
input:
read testEnv/grades2.csv as gradeFile;
end input;

actions:
gradeFile subset hw = [col hw1 to col hw5];
gradeFile subset quizzes = [col quiz1 to col quiz5];
gradeFile subset tests = [col test1, col test2];
gradeFile subset finalSet = [col final];

function get_percent = (value / 100);
function add_extra_credit = value + 5;
num hw_avg = avg hw max 100;
num quiz_avg = avg quizzes max 100;
num test_avg = avg tests max 100;
num final_avg = avg finalSet max 100;

end actions;

output:
add hw_avg to gradeFile;
add quiz_avg to gradeFile;
add test_avg to gradeFile;
add final_avg to gradeFile;
use add_extra_credit on hw;
add hw_avg to gradeFile;

write gradeFile ../outputs/hw-ec.csv;
end output;
~~~

Output:

![hw-ec.csv](./screenshots/hw-ec.JPG)

grades2-students
-------------

Input:

![grades2.csv](./screenshots/grades2.JPG)

Script:

~~~
input:
read testEnv/grades2.csv as gradeFile;
end input;

actions:
gradeFile subset danSet = [row Dan];
gradeFile subset trevorSet = [row Trevor];

cell danHW1 = gradeFile.hw1.Dan;
cell danHW3 = gradeFile.hw3.Dan;

gradeFile subset danHW = [danHW1, danHW3];

num dan_min = min danSet;
num dan_max = max danSet;
num dan_avg = avg danSet max 100;
num trevor_min = min trevorSet;
num trevor_max = max trevorSet;
num trevor_avg = avg trevorSet max 1;

function add_ec = value + 3;
function get_percent = value / 100;

end actions;

output:
add dan_min to gradeFile;
add dan_max to gradeFile;
add dan_avg to gradeFile;
use add_ec on danHW;
add dan_min to gradeFile;
add dan_max to gradeFile;
add dan_avg to gradeFile;

use get_percent on trevorSet;
add trevor_min to gradeFile;
add trevor_max to gradeFile;
add trevor_avg to gradeFile;

write gradeFile ../outputs/dan-trevor-info.csv;
end output;
~~~

Output:

![dan-trevor-info.csv](./screenshots/dan-trevor-info.JPG)


Grammar
===============

The following grammar is defined for the language:

~~~
grammar CSVScript;

start   : input actions output EOF ;

input   : 'input:' inputStatement 'end input' ';' ;
inputStatement  : 'read' filename 'as' ID inputFlags ';' inputStatement
                | /* epsilon */
                ;
inputFlags      : '(' inputFlag ')'
                | /* epsilon */
                ;
inputFlag       : 'noRowHeader'
                | 'noColHeader'
                | 'noRowHeader' ',' 'noColHeader'
                | 'noColHeader' ',' 'noRowHeader'
                ;
/*End input phase*/

actions			: 'actions:' actionBlock 'end actions' ';' ;
actionBlock		: action ';' actionBlock
				| /* epsilon */
				;
action			: ifStatement
				| subsetAssignment
				| cellAssignment
				| numAssignment
				| functionAssignment
				;

subsetAssignment: ID 'subset' ID '=' set; // First ID is fileVar, second is subsetVar

set				: '[' references ']';
references		: reference
				| reference ',' references
				;

reference		: 'row' ID //subset reference
                | 'col' ID
				| cellReference // colName.rowName
				| reference 'to' reference
				;

cellAssignment	: 'cell' ID '=' cellReference;

numAssignment   : 'num' ID '=' numVal ;

numVal          : INT
                | realNumber
                | opFunc
                | expr
                ;

opFunc          : 'max' ID
                | 'min' ID
                | 'avg' ID 'max' value
                | /* epsilon */
                ;

cellReference   : THIS '.' 'col' '.' ID
                | THIS '.' ID '.' 'row'
                | ID '.' ID '.' ID // colName.rowName
                | ID // Cell variable name
                ;

r				: ID ':' expr rules;

rules			: ',' r //ID corresponds to a subset or cell
				|
				;

/*Math portion*/
expr			: term
                | expr '+' term
                | expr '-' term
                ;

term			: factor
                | term '*' factor
                | term '/' factor
                ;

factor			: '(' expr ')'
                | VAL
				| value
				| variable
				;
/*End Math portion*/

variable        : ID
                | cellReference
                ;

functionAssignment: 'function' ID '=' expr ; //A rule is a mathematical operation to apply to the value of a cell or subset

ifStatement		: 'if' '(' conditional ')' actionBlock 'end if';

conditional		: value OPERATOR value
				| '('conditional')' AND '('conditional')'
				| '('conditional')' OR '('conditional')'
				;

value			: INT
				| realNumber
				;
/*End actions phase*/

output          : 'output:' outputStatement outputWriteSt 'end output' ';' ;
//outputStatement : outputRule outputAdd outputWrite ;
outputStatement : outputRule outputStatement
                | outputAdd outputStatement
                |
                ;

outputRule      : 'use' ID 'on' ID ';' ;//first ID corresponds to rule. Second ID corresponds to set.

outputAdd       : 'add' ID 'to' ID ';' ; // first ID corresponds to num var, second ID corresponds to inFile

outputWriteSt   : outputWrite outputWriteCont;
outputWriteCont : outputWrite outputWriteCont
                | /* epsilon */
                ;

outputWrite     : 'write' ID filename ';' ; //ID corresponds to a inFile

filename	    : './' filename
                | '../' filename
                | '/' filename
                | ID '.csv'
				| ALPHANUM '.csv';

realNumber		: INT '.' INT ;

INT     : [0-9]+ ;
AND     : 'and' | 'AND' ;
OR      : 'or' | 'OR' ;
VAL     : 'value';
THIS    : 'this';
OPERATOR: ('>=' | '<=' | '>' | '<' | '==' | '!=');
ID      : [a-zA-Z_] [0-9a-zA-Z_]+ ;
ALPHANUM: [0-9a-zA-Z_/\-]+ ;
NEWLINE : '\r'? '\n' -> skip;
WS      : [ \t]+ -> skip ;  // tells ANTLR to ignore these
~~~

The grammar matches the language as expected and is 
able to handle all the functionality we have currently 
designed the language with.


Translation Behind-The-Scenes
=======================

Variables
--------
All input files are read in as 2D arrays of strings. 
Those strings are then stored in a HashMap data type with the
key being the variable name the user assigned to that input file.

**Headers:** There are 2 separate HashMaps. One for column headers 
and the other for row headers. The key is the
header name and the value is the index of that row/column 
in the corresponding file's 2d array.

**Subsets:** Subsets are a class that contain the string of the 
in-file name and a linked list of cell locations. Subset 
variables are stored in a HashTable.

**Cells:** Cells can be referenced by the format 
fileVar.colHeader.rowHeader or by variable name if 
previously declared using `cell foo = inFile.col.row`. 
It can be used to access the value at that cell or to 
define a range or location in a subset. Visiting a 
cellReference returns the location of the cell and sets 
the currentCell value to the proper cell object, which 
contains the in-file variable name and the cell location 
within that file, as well as a getVal function.

Output
------
In the output, functions can be applied to certain subsets. 
This is achieved by storing the function context at assignment
and visiting it while parsing the use rule.
Numerical variable contexts are also stored, which 
allows the program to evaluate a numerical operation before 
and after a function is applied.

Reflection
===============

P01
-------------

This grammar is not exhaustive, but it covers most cases
fairly well. It is possible that we will add more functionality
to the language in the future, in which case we would
have to add to the grammar. We may also go back and restructure
the grammar in places to make it less ambiguous, especially
if we discover issues further down the line. However,
at this point in time the grammar works quite well for
our purposes and provides a strong starting point for
developing the language.

P02
---------------

At this point, the grammar should be fully functional. Perhaps some adjustments will be made to simplify parser
implementation. The grammar has displayed expected behavior for various syntax errors and valid inputs.

P03
--------------

We made some adjustments to the grammar based on what we thought would 
be useful for the user.
We decided that for loops were unnecessarily complicated - both 
for the user and for the implementation - so we replaced them with 
a number variable assignment that can also implement an 
minimum, maximum, and average operation of a subset. 
We did this because the number of contexts where for loops 
would be used was quite slim, so we removed them while also 
maintaining and simplifying their most common use case.
We also decided to remove schemes, as we didn't have time to fully 
define what their use would be and to get a good understanding of 
how they would be implemented. They only provided a minor part 
of functionality, so that wasn't too concerning.

However, we saw some promising results with subsets and functions! 
The subset/rule functionality should give some powerful options for 
the user to analyze and manipulate data. In addition, the min/max/avg 
operators were a nice addition to the language.

We still need to put some finishing touches on the output phase 
of the program, but overall we're pretty encouraged by the progress 
we've seen!

P04
-------------

The language is now at a point where it is functional and 
usable. There are more potential changes we could make to it in 
the future, but we're pretty happy with where it's at right now.
The grammar has been fully fleshed out to allow for all the 
core functionality that the language is intended to accomplish.

It ended up being more complicated than we thought to get the 
language to this point - there were a lot of edge cases and 
specific functionality that we hadn't considered and had to rework 
our grammar and implementation slightly to support. However, 
the language should now be at a point where it accomplishes 
its intended purpose. It is simple to use but still allows for 
advanced manipulation and analysis.

Overall, this project was fun to work on! It was a lot of work,
but it was really interesting to figure out how to approach actually 
implementing the language, and it was quite rewarding to have everything 
come together. Perhaps we'll be able to use our language in the future!



<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
