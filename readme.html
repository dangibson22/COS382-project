**Gradebook DSL**


Author
===============

<div class="noheader firstcol">
    |             
------------------|-------------
name              | Daniel Gibson & Trevor Mitchell
computer + OS     | Euler lab machines (Linux)
</div>


Introduction to Language
===============

**Domain:** Teachers managing a CSV gradebook

**Problem:** This language is meant to enable educators to perform 
manipulations on a gradebook, such as getting the highest / lowest 
grade, an average for an assignment, or even curving a grade or 
applying a new weighting system.


Variable Types and Declarations
================================

file:
--------
a CSV file that has been read in as a 2d array

Example:<br>
`read foo.csv as bar;` creates a file variable named bar.<br>
`read foo.csv as bar (noColHeaders)` You can also add flags if your spreadsheet does not contain headers, such as the
sample below which contains no column headers. Options include `(noColHeaders, noRowHeaders)`
<div class="noheader">
    |
------------------|----|----|----|----
Quiz1Scores       | 12 | 14 | 10 | 12
Quiz2Scores       | 43 | 44 | 39 | 45
</div>


headers:
--------
upon reading in a file, the script is populated with variables that refer to row and column headers, allowing
the programmer to access cells with `tableVar.colHeaderName.rowHeaderName`. If the noRowHeader or noColHeader is set,
the respective field is populated with headers "row_1, row_2, ..."

If a header cell is empty, its name will become "col_n" where n is the index of the header. If a row and column have
the same name, the "_row" is appended to the end of the row. If two columns share the same name, then the second one
will have "_n" appended at the end, where n is the occurrence (2 for the second, 3 for the third, and so on)

subset:
-------
an object that contains a set of specified cells that can all be manipulated at once.

Examples:<br>
`subset foo = [table.row.col to table.row2.col2];` creates a subset that contains all cells bounded by the
two cells.<br>
`subset foo = [row a to row b];` contains all cells in the box bounded by those rows. The language can use `col`
but cannot compute a range of a row to a column.<br>
`subset foo = [table.col.row, col a to col b];` Using commas, the programmer can specify a set of cells that are
not connected.

cell:
---------
a reference to a specific cell in a specific table.

Example:<br>
`cell foo = table.col.row;` creates a cell variable 'foo' that refers to the reference.

function
----------
Defines a mathematical function to apply to a subset in the output section.<br>
The `value` keyword is used to access the current value in the cell being manipulated.<br>
You can also access the current cell's location by using `this.col` or `this.foo.row`, allowing
you to access a different cell in the same row or the same column.

Examples:<br>
`function add2 = value + 2;` adds 2 to each cell in the subset.<br>
`function convertToPercent = value / this.col.total;` accesses the cells value and divides it by the total value
for that same column (works if assignments are separated by column).

Script Overview
===============

Input
----------------

Given a csv file, the language will create variables for the 2d array of data, the column headers, and the row headers.

**Invalid characters**: If a column header contains invalid characters, such as '&'' or '$', they will be removed from the column reference.
Spaces in column headers will be replaced with underscores.

**Conflicting names**: If 2 columns contain the same name, the second one will have the number 1 appended to the end, and the next 2, and so on.
If a column and row share the same name, '_row' will be appended to the row version.

Actions
---------------

Within the actions section, the programmer can declare subsets of specific cells as well as functions, or mathematical
manipulations to apply to each cell within those subsets.

The actions section is intended to define any 
modifications to be made to the data. This way, all 
computation is contained within the actions section, 
and the output section only uses the precomputed 
data types to prepare the output.


Output
---------------

The output section is used to define the structure of the resulting file. 
It applies pre-defined rules and functions to certain subsets
and writes those results to the specified CSV file.

Sample Program
===============

The following code is an example of a program written 
in this language. This is what we used to test the 
grammar and help structure it.

~~~
INSERT PROGRAM HERE
~~~

Grammar
===============

The following grammar is defined for the program:

~~~
INSERT FINAL GRAMMAR HERE
~~~

The grammar matches the program as expected and is 
able to handle all the functionality we have currently 
designed the program with.


Translation Behind-The-Scenes
=======================

Variables
--------

All input files are read in as 2d arrays of strings. Those strings are then stored in a HashMap data type with the
key being the variable name the user assigned to that input file.

**Headers:** There are 2 separate HashMaps. One for column headers and the other for row headers. The key is the
header name and the value is the index of that row/column in the corresponding file's 2d array

**Subsets:** Subsets are a class that contain the string of the in-file name and a linked list of cell locations. Subset
variables are stored in a HashTable.

**Cells:** Cells can be referenced by the format fileVar.colHeader.rowHeader or by variable name if previously declared
using `cell foo = inFile.col.row`. It can be used to access the value at that cell or to define a range or location in
a subset. Visiting a cellReference returns the location of the cell and sets the currentCell value to the proper cell
object, which contains the in-file variable name and the cell location within that file, as well as a getVal function.


Testing
====================

A whole suite of test files were used to check against isolated issues, such as no output file, an integer being used
as a variable id, actions in the output block, and no input block. We also tested against a larger script that should
utilize most, if not all of the grammar rules.

Reflection
===================

P01
-------------

This grammar is not exhaustive, but it covers most cases
fairly well. It is possible that we will add more functionality
to the language in the future, in which case we would
have to add to the grammar. We may also go back and restructure
the grammar in places to make it less ambiguous, especially
if we discover issues further down the line. However,
at this point in time the grammar works quite well for
our purposes and provides a strong starting point for
developing the language.

P02
---------------

At this point, the grammar should be fully functional. Perhaps some adjustments will be made to simplify parser
implementation. The grammar has displayed expected behavior for various syntax errors and valid inputs.

P03
--------------

We made some adjustments to the grammar based on what we thought would 
be useful for the user.
We decided that for loops were unnecessarily complicated - both 
for the user and for the implementation - so we replaced them with 
a number variable assignment that can also implement an 
minimum, maximum, and average operation of a subset. 
We did this because the number of contexts where for loops 
would be used was quite slim, so we removed them while also 
maintaining and simplifying their most common use case.
We also decided to remove schemes, as we didn't have time to fully 
define what their use would be and to get a good understanding of 
how they would be implemented. They only provided a minor part 
of functionality, so that wasn't too concerning.

However, we saw some promising results with subsets and functions! 
The subset/rule functionality should give some powerful options for 
the user to analyze and manipulate data. In addition, the min/max/avg 
operators were a nice addition to the language.

We still need to put some finishing touches on the output phase 
of the program, but overall we're pretty encouraged by the progress 
we've seen!



<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
